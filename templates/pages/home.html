<html !DOCTYPE>
  <head>

    <link rel="stylesheet" href="/static/css/stylesheet.css" type="text/css"/>
  </head>
  <body>
    <main>
    <h1 class="logo">TimeGeist</h1>
      <section id="track-info">
        <p id="track-name"></p>
        <p id="track-artist"></p>
        <p id="track-notes"></p>
        <div class="track-buttons">
          <div class="button" id="good-track"></div>
          <div class="button" id="bad-track"></div>
        </div>
      </section><section id="main-input">
        <input id="user-year" type="number" value=1900 min=1900 max=2015/>
        <div class="button" id="go-time"><span>Go Time</span></div>
      </section>
      <section class="message-zone"></section>
    </main>
  </body>
  <script>

    window.onload = init;
    var context;
    var bufferLoader;
    var CrossfadePlaylistSample;

    function init() {
      // Fix up prefixing
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      context = new AudioContext();
    }

    var $go = document.querySelector('#go-time');
    var $input = document.querySelector('#user-year');
    var $messageZone = document.querySelector('.message-zone');
    var activeYear;
    var eventPublished = setInterval(function() {
      if ($input.value) {
        getEvents(activeYear);
      } else {
        // TODO error validation or just always have default value
        // $messageZone.textContent = 'You done messed up.';
      }
    }, 7000);

    var coastMode = true;
    var coasting = setInterval(function() {
      if (coastMode) {
        $input.value = parseInt(activeYear) + 1;
        fireItUp();
      } else {
        clearInterval(coasting);
      }
    }, 25000);
    document.onkeyup = function(e) {
      if (e.keyCode === 13) {
        if (activeYear !== $input.value) {
          fireItUp();
        }
      }
    };
    $go.addEventListener('click', function(event) {
      if (activeYear !== $input.value) {
        fireItUp();
      }
    });

    function getMessageForYear(year) {
      // TODO
      if (year < 1910) return 'Old timey times.';
      if (year < 1920) return 'The War to End All Wars.';
      if (year < 1930) return 'Roaring 20s. Prohibition.';
      if (year < 1940) return 'Depression. Roosevelt. Rise of fascism.';
      if (year < 1950) return 'Wars. Big Wars.';
      if (year < 1960) return 'McCarthyism and the beginning of the Cold War';
      if (year < 1970) return 'Vietnam. Hippies. Mad Men.';
      if (year < 1980) return 'Sex. Drugs. Rock & Roll.';
      if (year < 1990) return 'Computers? Arena Rock. Back to the Future';
      if (year < 2000) return 'Internet Age. Globalization.' 
      if (year < 2010) return 'The aughts. iPods. Iraq.';
      if (year < 2020) return 'It\'s still happening.';

      return 'YOLO';
    }

    function fireItUp() {
      while ($messageZone.firstChild) {
        $messageZone.removeChild($messageZone.firstChild);
      }
      activeYear = $input.value;
      sendMessage('Welcome to ' + activeYear + ' - ' + getMessageForYear(activeYear), 'h1');
      searchTracks($input.value, function(response) {
        console.log($input.value, response);
      });
    }

    function sendMessage(content, elType) {
      elType = elType || 'p';
      var $p = document.createElement(elType);
      $p.textContent = content;
      $firstP = $messageZone.querySelector(elType);
      $messageZone.insertBefore($p, $firstP);
    }

    // Spotify Stuff

    function updateTrackInfo(track) {
      console.log('Now playing', track);
      var $name = document.querySelector('#track-name');
      var $artist = document.querySelector('#track-artist');
      //var $notes = document.querySelector('#track-notes');
      $name.textContent = track.name;
      $artist.textContent = track.artist;
      //$notes.textContent = track.notes;
    }

    function searchTracks(query, callback) {
      var trackList;
      //get('https://api.spotify.com/v1/search?q=' + query + '&type=track', function(xhr) {
      get('/api/v1.0/songs/' + query, function(xhr) {
        trackList = JSON.parse(xhr.responseText);
        trackList = trackList.filter(function(track) {
          return track.preview_url;
        });

        if (bufferLoader) {

          console.log('Just need to update the bufferLoader');
          bufferLoader.trackList = trackList;
          bufferLoader.urlList = [];
          bufferLoader.bufferList = [];
          bufferLoader.loadCount = 0;
        } else {
          bufferLoader = new BufferLoader(
            context,
            trackList,
            finishedLoading
          );
        }
        bufferLoader.load();
      });
    };


    // Nice helpers from http://www.html5rocks.com/en/tutorials/webaudio/intro/
    function BufferLoader(context, trackList, callback) {
      this.context = context;
      this.trackList = trackList;
      this.onload = callback;
      this.bufferList = new Array();
      this.loadCount = 0;
    }
    BufferLoader.prototype.loadBuffer = function(url, index) {
      // Load buffer asynchronously
      var request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = "arraybuffer";
      var loader = this;
      request.onload = function() {
        // Asynchronously decode the audio file data in request.response
        loader.context.decodeAudioData(
          request.response,
          function(buffer) {
            if (!buffer) {
              alert('error decoding file data: ' + url);
            }
            loader.bufferList[index] = buffer;
            if (++loader.loadCount == loader.urlList.length)
              loader.onload(loader.bufferList, loader.trackList);
          },
          function(error) {
            console.log('decodeAudioData error', error);
            if (++loader.loadCount == loader.urlList.length)
              loader.onload(loader.bufferList, loader.trackList);
          }
        );
      }
      request.onerror = function() {
        alert('BufferLoader: XHR error');
      }
      request.send();
    }

    BufferLoader.prototype.load = function() {
      this.urlList = this.trackList
          .map(function(track) {
            return track.preview_url;
          });
      for (var i = 0; i < this.urlList.length; ++i)
      this.loadBuffer(this.urlList[i], i);
    }

    function finishedLoading(bufferList, trackList) {
      console.log('We are finished loading for sure');
      // Create two sources and play them both together.
      if (CrossfadePlaylistSample) {
        console.log('We only need an update');
        CrossfadePlaylistSample.bufferList = bufferList;
        CrossfadePlaylistSample.trackList = trackList;
        CrossfadePlaylistSample.playIdx = 0;
        return;
      }

      CrossfadePlaylistSample = {
        FADE_TIME: 1, // Seconds
        playing: false,
        playIdx: 0,
        bufferList: bufferList,
        trackList: trackList
      };

      CrossfadePlaylistSample.play = function() {
        var ctx = this;
        playHelper();

        function createSource(buffer) {
          var source = context.createBufferSource();
          var gainNode = context.createGain ? context.createGain() : context.createGainNode();
          source.buffer = buffer;
          // Connect source to gain.
          source.connect(gainNode);
          // Connect gain to destination.
          gainNode.connect(context.destination);
          return {
            source: source,
            gainNode: gainNode
          };
        }

        function playHelper() {
          ctx.playIdx = ctx.playIdx === ctx.bufferList.length - 1 ? 0 : ctx.playIdx;
          if(!ctx.bufferList[ctx.playIdx]) {
            playIdx += 1;
            arguments.callee();
          }

          updateTrackInfo(ctx.trackList[ctx.playIdx]);
          var bufferNow = ctx.bufferList[ctx.playIdx];
          var playNow = createSource(bufferNow);
          var source = playNow.source;
          ctx.source = source;
          var gainNode = playNow.gainNode;
          var duration = bufferNow.duration;
          var currTime = context.currentTime;
          // Fade the playNow track in.
          gainNode.gain.linearRampToValueAtTime(0, currTime);
          gainNode.gain.linearRampToValueAtTime(1, currTime + ctx.FADE_TIME);
          // Play the playNow track.
          source.start ? source.start(0) : source.noteOn(0);
          // At the end of the track, fade it out.
          gainNode.gain.linearRampToValueAtTime(1, currTime + duration-ctx.FADE_TIME);
          gainNode.gain.linearRampToValueAtTime(0, currTime + duration);
          // Schedule a recursive track change with the tracks swapped.
          var recurse = arguments.callee;
          ctx.timer = setTimeout(function() {
            ctx.playIdx += 1;
            recurse();
          }, (duration - ctx.FADE_TIME) * 1000);
        }
      };

      CrossfadePlaylistSample.stop = function() {
        clearTimeout(this.timer);
        this.source.stop ? this.source.stop(0) : this.source.noteOff(0);
      };

      CrossfadePlaylistSample.next = function() {
        clearTimeout(this.timer);
        this.source.stop ? this.source.stop(0) : this.source.noteOff(0);
      };

      CrossfadePlaylistSample.toggle = function() {
        this.playing ? this.stop() : this.play();
        this.playing = !this.playing;
      };
      CrossfadePlaylistSample.play();
    }



    // Helpers
    function getEvents(year) {
      var json, msgIdx;
      get('/api/v1.0/events/' + year, function(xhr) {
        json = JSON.parse(xhr.responseText);
        if (json.status === 'empty') {
          // TODO not sure what to do in this case
        } else {
          msgIdx = Math.round(Math.random() * (json.length - 1));
          sendMessage(json[msgIdx][1]);
        }
      });
    }
    function getSongs(year) {
      get('/api/v1.0/songs/' + year, function(xhr) {
        console.log(xhr);
      });
    }
    function get(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200 && callback) {
          callback(xhr);
        }
      }
      xhr.send();
    }

  </script>
</html>
