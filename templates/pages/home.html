<html !DOCTYPE>
  <head>

    <link rel="stylesheet" href="/static/css/stylesheet.css" type="text/css"/>
    <script src="//use.typekit.net/uiq7hdf.js"></script>
    <script>try{Typekit.load();}catch(e){}</script>
  </head>
  <body>
    <main>
    <h1 class="logo">TimeGeist</h1>
      <section id="track-info">
        <h1>Select a year to begin! You can also just try a random year.</h1>
        <div class="thumbnail" id="track-image"></div>
        <div id="track-stats">
          <p id="track-name"></p>
          <p id="track-artist"></p>
          <p id="track-notes"></p>
        </div>
        <div id="upcoming-tracks">
        </div>
        <div class="track-buttons">
          <div class="button" id="good-track">Good Track!</div>
          <div class="button" id="bad-track">So bad!</div>
        </div>
      </section><section id="main-input">
        <input id="user-year" type="number" value=2001 min=1900 max=2015/>
        <div class="button" id="go-time"><span>I want this year!</span></div>
        <div class="button" id="go-random"><span>I want a random year!</span></div>
      </section>
      <section class="message-zone"></section>
    </main>
  </body>
  <script>

    window.onload = init;
    var context;
    var bufferLoader;
    var CrossfadePlaylistSample;
    var $go = document.querySelector('#go-time');
    var $input = document.querySelector('#user-year');
    var $messageZone = document.querySelector('.message-zone');
    var activeYear;

    function init() {
      // Fix up prefixing
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      context = new AudioContext();
      sendMessage('', 'h1');
      getFontForYear($input.value);
      document.querySelector('body').addEventListener('touchstart', playSound, false);
    }

    function playSound(buffer) {
      var source = context.createBufferSource(); // creates a sound source
      source.buffer = buffer;                    // tell the source which sound to play
      source.connect(context.destination);       // connect the source to the context's destination (the speakers)
      source.start(0);                           // play the source now
                                                 // note: on older systems, may have to use deprecated noteOn(time);
    }


    var eventPublished = setInterval(function() {
      if ($input.value) {
        getEvents(activeYear);
      } else {
        // TODO error validation or just always have default value
        // $messageZone.textContent = 'You done messed up.';
      }
    }, 7000);

    // TODO add this to the interface. It's kind of a cool feature
    var coastMode = false;
    var coasting = setInterval(function() {
      if (coastMode) {
        $input.value = parseInt(activeYear) < 2014 ? parseInt(activeYear) + 1 : 1900;
        fireItUp();
      } else {
        clearInterval(coasting);
      }
    }, 25000);
    document.onkeyup = function(e) {
      if (e.keyCode === 13) {
        if (activeYear !== $input.value) {
          fireItUp();
        }
      }
    };
    $go.addEventListener('click', function(event) {
      if (activeYear !== $input.value) {
        fireItUp();
      }
    });
    function getRandomArbitrary(min, max) {
      return Math.round(Math.random() * (max - min) + min);
    }
    document.querySelector('#go-random').addEventListener('click', function(event) {
      $input.value = getRandomArbitrary(1899, 2014);
      if (activeYear !== $input.value) {
        fireItUp();
      }
    });

    function getFontForYear(year) {
      var $body = document.querySelector('main');
      if (year < 1910) { $body.className = 'tk-ltc-broadway'; return; }
      if (year < 1920) { $body.className = 'tk-ten'; return; }
      if (year < 1930) { $body.className = 'tk-ltc-broadway'; return; }
      if (year < 1940) { $body.className = 'tk-thirty'; return; }
      if (year < 1950) { $body.className = 'tk-grafolita-script'; return; }
      if (year < 1960) { $body.className = 'tk-clarendon-text-pro'; return; }
      if (year < 1970) { $body.className = 'tk-futura-pt'; return; }
      if (year < 1980) { $body.className = 'tk-cooper-black-std'; return; }
      if (year < 1990) { $body.className = 'tk-eighty'; return; }
      if (year < 2000) { $body.className = 'tk-ninety'; return; }
      if (year < 2010) { $body.className = 'tk-aught'; return; }
      if (year < 2020) { $body.className = 'tk-brandon-grotesque'; return; }

      return;
    }

    function getMessageForYear(year) {
      // TODO
      if (year < 1910) return 'Old timey times.';
      if (year < 1920) return 'The War to End All Wars';
      if (year < 1930) return 'Roaring 20s. Prohibition.';
      if (year < 1940) return 'Depression. Roosevelt. Rise of fascism.';
      if (year < 1950) return 'Wars. Big Wars.';
      if (year < 1960) return 'McCarthyism and the beginning of the Cold War';
      if (year < 1970) return 'Vietnam. Hippies. Mad Men.';
      if (year < 1980) return 'Groovy.';
      if (year < 1990) return 'Computers? Arena Rock. Back to the Future';
      if (year < 2000) return 'Internet Age. Globalization.' 
      if (year < 2010) return 'The aughts. iPods. Iraq.';
      if (year < 2020) return 'It\'s still happening.';

      return 'YOLO';
    }

    var $trackInfo = document.querySelector('#track-info');
    function fireItUp() {
      while ($messageZone.firstChild) {
        $messageZone.removeChild($messageZone.firstChild);
      }
      activeYear = $input.value;
      getFontForYear(activeYear);
      clearTrackInfo();
      sendMessage('Welcome to ' + activeYear + ' - ' + getMessageForYear(activeYear), 'h1');
      searchTracks($input.value, function(response) {
        console.log($input.value, response);
      });
    }

    function sendMessage(content, elType) {
      elType = elType || 'p';
      var $p = document.createElement(elType);
      $p.textContent = content;
      $firstP = $messageZone.querySelector(elType);
      $messageZone.insertBefore($p, $firstP);
    }

    function updateTrackInfo(track) {
      var $name = document.querySelector('#track-name');
      var $artist = document.querySelector('#track-artist');
      //var $notes = document.querySelector('#track-notes');
      $name.textContent = track.name;
      $artist.textContent = track.artist;
      //$notes.textContent = track.notes;
      $trackInfo.style.background = 'none';
      if (track && track.album && track.album.images && track.album.images.length > 1) {
        var albumImgUrl = track.album.images[1].url;
        console.log(track);
        document.querySelector('#track-image').style.background = 'url(' + albumImgUrl + ') no-repeat';
        document.querySelector('#track-image').style.backgroundSize = 'contain';
        document.querySelector('#track-image').style.display = 'inline-block';
      }
    }

    function clearTrackInfo() {
      [].forEach.call($trackInfo.querySelectorAll('p, h1'), function($p) {
        $p.textContent = '';
      });
      [].forEach.call($trackInfo.querySelectorAll('.thumbnail'), function($thumbnail) {
        $thumbnail.style.background = 'none';
        $thumbnail.style.display = 'none';
      });
      $trackInfo.querySelector('#track-image').style.display = 'none';
      $trackInfo.style.background = 'url(/static/img/clock.svg) no-repeat scroll center center';
      $trackInfo.style.backgroundSize = 'contain';
    }

    var addBufferImages = function(tracks) {
      var $upcoming = document.querySelector('#upcoming-tracks');
      while($upcoming.firstChild) {
        $upcoming.removeChild($upcoming.firstChild);
      }
      var $div;
      tracks.forEach(function(track) {
        if (track && track.album && track.album.images && track.album.images.length > 1) {
          $div = document.createElement('div');
          var albumImgUrl = track.album.images[1].url;
          $div.style.background = 'url(' + albumImgUrl + ') no-repeat';
          $div.style.backgroundSize = 'contain';
          $div.className = 'thumbnail upcoming';
          $upcoming.appendChild($div);
        }
      });
    };

    function searchTracks(query, callback) {
      var trackList;
      //get('https://api.spotify.com/v1/search?q=' + query + '&type=track', function(xhr) {
      get('/api/v1.0/songs/' + query, function(xhr) {
        trackList = JSON.parse(xhr.responseText);
        trackList = trackList.filter(function(track) {
          return track.preview_url;
        });

        if (bufferLoader) {

          console.log('Just need to update the bufferLoader');
          bufferLoader.trackList = trackList;
          bufferLoader.urlList = [];
          bufferLoader.bufferList = [];
          bufferLoader.loadCount = 0;
        } else {
          bufferLoader = new BufferLoader(
            context,
            trackList,
            finishedLoading
          );
        }
        bufferLoader.load();
      });
    };


    // Nice helpers from http://www.html5rocks.com/en/tutorials/webaudio/intro/
    function BufferLoader(context, trackList, callback) {
      this.context = context;
      this.trackList = trackList;
      this.onload = callback;
      this.bufferList = new Array();
      this.loadCount = 0;
    }
    BufferLoader.prototype.loadBuffer = function(url, index) {
      // Load buffer asynchronously
      var request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = "arraybuffer";
      var loader = this;
      request.onload = function() {
        // Asynchronously decode the audio file data in request.response
        loader.context.decodeAudioData(
          request.response,
          function(buffer) {
            if (!buffer) {
              alert('error decoding file data: ' + url);
            }
            loader.bufferList[index] = buffer;
            if (++loader.loadCount == loader.urlList.length)
              loader.onload(loader.bufferList, loader.trackList);
          },
          function(error) {
            console.log('decodeAudioData error', error);
            if (++loader.loadCount == loader.urlList.length)
              loader.onload(loader.bufferList, loader.trackList);
          }
        );
      }
      request.onerror = function() {
        alert('BufferLoader: XHR error');
      }
      request.send();
    }

    BufferLoader.prototype.load = function() {
      this.urlList = this.trackList
          .map(function(track) {
            return track.preview_url;
          });
      for (var i = 0; i < this.urlList.length; ++i)
      this.loadBuffer(this.urlList[i], i);
    }

    function finishedLoading(bufferList, trackList) {
      console.log('We are finished loading for sure');
      // Create two sources and play them both together.
      if (CrossfadePlaylistSample) {
        console.log('We only need an update');
        CrossfadePlaylistSample.bufferList = bufferList;
        CrossfadePlaylistSample.trackList = trackList;
        CrossfadePlaylistSample.playIdx = 0;
        CrossfadePlaylistSample.next();
        return;
      }

      CrossfadePlaylistSample = {
        FADE_TIME: 1, // Seconds
        playing: false,
        playIdx: 0,
        bufferList: bufferList,
        trackList: trackList
      };

      CrossfadePlaylistSample.play = function() {
        var ctx = this;
        playHelper();

        function createSource(buffer) {
          var source = context.createBufferSource();
          var gainNode = context.createGain ? context.createGain() : context.createGainNode();
          source.buffer = buffer;
          // Connect source to gain.
          source.connect(gainNode);
          // Connect gain to destination.
          gainNode.connect(context.destination);
          return {
            source: source,
            gainNode: gainNode
          };
        }

        function getNextTracks(num) {
          num = num || 5;
          var ub = ctx.trackList.length - 1;
          num = num < ub ? num : ub;

          if (ctx.playIdx + num - 1 < ub) {
            return ctx.trackList.slice(ctx.playIdx + 1, ctx.playIdx + num);
          } else {
            var tailIndex = ctx.playIdx - ub;
            var endSlice = ctx.trackList.slice(tailIndex);
            var beginningSlice = ctx.trackList.slice(0, num + tailIndex);
            return endSlice.concat(beginningSlice);
          }
        }

        function playHelper() {
          ctx.playIdx = ctx.playIdx === ctx.bufferList.length - 1 ? 0 : ctx.playIdx;
          if(!ctx.bufferList[ctx.playIdx]) {
            ctx.playIdx += 1;
            arguments.callee();
          }

          updateTrackInfo(ctx.trackList[ctx.playIdx]);
          addBufferImages(getNextTracks());
          var bufferNow = ctx.bufferList[ctx.playIdx];
          var playNow = createSource(bufferNow);
          var source = playNow.source;
          ctx.source = source;
          var gainNode = playNow.gainNode;
          ctx.gainNode = gainNode;
          var duration = bufferNow.duration;
          var currTime = context.currentTime;
          // Fade the playNow track in.
          gainNode.gain.linearRampToValueAtTime(0, currTime);
          gainNode.gain.linearRampToValueAtTime(1, currTime + ctx.FADE_TIME);
          // Play the playNow track.
          source.start ? source.start(0) : source.noteOn(0);
          // At the end of the track, fade it out.
          gainNode.gain.linearRampToValueAtTime(1, currTime + duration-ctx.FADE_TIME);
          gainNode.gain.linearRampToValueAtTime(0, currTime + duration);
          // Schedule a recursive track change with the tracks swapped.
          var recurse = arguments.callee;
          ctx.timer = setTimeout(function() {
            ctx.playIdx += 1;
            recurse();
          }, (duration - ctx.FADE_TIME) * 1000);
        }
      };

      CrossfadePlaylistSample.stop = function() {
        clearTimeout(this.timer);
        this.source.stop ? this.source.stop(0) : this.source.noteOff(0);
      };

      CrossfadePlaylistSample.next = function() {
        clearTimeout(this.timer);
        this.source.stop ? this.source.stop(0) : this.source.noteOff(0);
        this.playIdx += 1;
        this.play();
      };

      CrossfadePlaylistSample.playTrack = function(playIdx) {
        clearTimeout(this.timer);
        this.source.stop ? this.source.stop(0) : this.source.noteOff(0);
        this.playIdx += playIdx;
        this.play();
      };

      CrossfadePlaylistSample.toggle = function() {
        this.playing ? this.stop() : this.play();
        this.playing = !this.playing;
      };
      CrossfadePlaylistSample.play();
    }



    // Helpers
    function getEvents(year) {
      var json, msgIdx;
      get('/api/v1.0/events/' + year, function(xhr) {
        json = JSON.parse(xhr.responseText);
        if (json.status === 'empty') {
          // TODO not sure what to do in this case
        } else {
          msgIdx = Math.round(Math.random() * (json.length - 1));
          sendMessage(json[msgIdx][1]);
        }
      });
    }
    function getSongs(year) {
      get('/api/v1.0/songs/' + year, function(xhr) {
        console.log(xhr);
      });
    }
    function get(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200 && callback) {
          callback(xhr);
        }
      }
      xhr.send();
    }

  </script>
</html>
