<html !DOCTYPE>
<head>
  <link rel="icon" type="image/svg+xml" href="/static/img/timegeist.ico">
  <link rel="stylesheet" href="/static/css/stylesheet.css" type="text/css"/>
  <script src="//use.typekit.net/uiq7hdf.js"></script>
  <script>try{Typekit.load();}catch(e){}</script>
  <script src="/static/js/crossfade_playlist.js"></script>
  <script src="/static/js/buffer_loader.js"></script>
  <script src="/static/js/api.js"></script>
  <script src="/static/js/year.js"></script>
  <script src="/static/js/pubsub.js"></script>
  <script src="/static/lib/react.js"></script>
  <script src="/static/lib/JSXTransformer.js"></script>
  <title>Welcome to TimeGeist!</title>

</head>
<body>
  <main>
  <h1 class="logo">TimeGeist</h1>
    <section id="main-input">
      <div class="group">
        <input id="user-year" type="number" value=2001 min=1900 max=2015 required>
        <span class="highlight"></span>
        <span class="bar"></span>
        <label>Year</label>
      </div>
      <div class="button" id="go-time"><span>I want this year!</span></div>
      <div class="button" id="go-random"><span>Show a random year!</span></div>
    </section>
    <section id="track-info">
      <h1>Select a year between 1900 and 2015 to begin! You can also just try a random year.</h1>
      <div id="track-upcoming-container">
        <div id="track-view-container">
          <div class="thumbnail" id="track-image"></div>
          <div id="track-stats">
            <p id="track-name"></p>
            <p id="track-artist"></p>
            <p id="track-notes"></p>
          </div>
        </div>
        <div id="upcoming-tracks"></div>
      </div>
      <div class="track-buttons">
        <div class="button" id="good-track"><span>Good Track!</span></div>
        <div class="button" id="bad-track"><span>Skip</span></div>
      </div>
    </section><section class="message-zone"></section>
  </main>
</body>
<script type="text/jsx">
  var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;

  var MessageBox = React.createClass({
    loadMessagesFromServer: function(year) {
      api.getEvents(year, function(events) {
        this.setState({ data: events, slice: this.getEventSlice(events) }); 
      }.bind(this));
    },
    pushNewEvent: function() {
      if (!this.state.data.length) return;

      var idx = Math.floor(Math.random() * this.state.data.length);
      var newSlice = this.state.slice;

      // Basic check to make sure we are getting a new event 
      var strings = newSlice.map(function(event) { return event[1] });
      while(strings.indexOf(this.state.data[idx][1]) > -1 && this.state.data.length > this.state.slice.length) {
        idx = Math.floor(Math.random() * this.state.data.length);
      }
      newSlice.unshift(this.state.data[idx]);
      newSlice.pop();
      this.setState({ slice: newSlice });
    },
    getEventSlice: function(events) {
      var sliceSize = 3;
      var idx = Math.floor(Math.random() * events.length - sliceSize);
      return events.slice(idx, idx + sliceSize);
    },
    getInitialState: function() {
      return { data: [], slice: [] };
    },
    componentDidMount: function() {
      document.addEventListener('visibilitychange', function() {
        console.log('vis change', document.hidden);
        if (document.hidden) {
          this.setState({ slice: [] });
          return;
        } else {
          this.setState({ slice: this.getEventSlice(this.state.data) });
        }
      }.bind(this), false);
      setInterval(function() {
        console.log('interval', document.hidden);
        if (document.hidden) return;
        if (this.state.slice.length) {
          this.pushNewEvent();
        } else {
          this.setState({ slice: this.getEventSlice(this.state.data) });
        }
      }.bind(this), 7000);
      events.sub('yearChange', function(args) {
        if (window.cache && window.cache.events && typeof window.cache.events[args.year] !== 'undefined') {
          var events = window.cache.events[args.year];
          this.setState({ data: events, slice: this.getEventSlice(events) });
        } else {
          this.loadMessagesFromServer(args.year);
        }
      }.bind(this));
    },
    render: function() {
      return (
        <div className='message-box'>
          <MessageList slice={this.state.slice} />
        </div>
      );
    }
  });
  var MessageList = React.createClass({
    render: function() {
      var messageNodes = this.props.slice.map(function(message, idx) {
        return (
          <Message key={message[1]} message={message[1]}></Message>
        );
      });
      return (
          <div className='message-list'>
            <ReactCSSTransitionGroup transitionName="fade">
              {messageNodes}
            </ReactCSSTransitionGroup>
          </div>
      );
    }
  });
  var Message = React.createClass({
    render: function() {
        return (
          <p className='message'>
            {this.props.message}
          </p>
        );
    }
  });

  React.render(
    <MessageBox />,
    document.querySelector('.message-zone')
  );
</script>
<script>

window.onload = init;

function init() {

  window.cache = {};
  window.bufferLoader, window.playlist;

  var $body = document.querySelector('body');
  var $go = document.querySelector('#go-time');
  var $input = document.querySelector('#user-year');
  var $trackInfo = document.querySelector('#track-info');
  var $goodTrack = document.querySelector('#good-track');
  var $badTrack  = document.querySelector('#bad-track');

  var activeYear;

  // Fix up prefixing
  window.AudioContext = window.AudioContext || window.webkitAudioContext;
  var context = new AudioContext();

  playlist = Object.create(CrossfadePlaylist.prototype, {
    FADE_TIME: {
      value: 1
    }, // Seconds
    playing: {
      value: undefined,
      writable: true
    },
    playIdx: {
      value: 0,
      writable: true
    },
    trackList: {
      value: [],
      writable: true
    },
    context: {
      value: context,
      writable: true
    }
  });

  bufferLoader = Object.create(BufferLoader.prototype, {
    context: {
      value: context,
      writable: true
    },
    trackList: {
      value: [],
      writable: true
    },
    onload: {
      value: playlist.loadTrack.bind(playlist)
    },
    activeYear: {
      value: activeYear,
      writable: true
    }
  });
  events.sub('yearChange', function(data) {
    playlist.switching = true;
    bufferLoader.activeYear = data.year;
  });
  events.pub('sendMessage', { message: '', elType: 'h1' });

  // XXX slight hack/necessity to allow sound to play in iOS
  document.querySelector('body').addEventListener('touchstart', playSound, false);

  // XXX Truly temporary
  function playSound(buffer) {
    var source = context.createBufferSource(); // creates a sound source
    source.buffer = buffer;                    // tell the source which sound to play
    source.connect(context.destination);       // connect the source to the context's destination (the speakers)
    source.start(0);                           // play the source now
                                               // note: on older systems, may have to use deprecated noteOn(time);
  }

  // TODO add this to the interface. It's kind of a cool feature
  var coastMode = false;
  var coasting = setInterval(function() {
    if (coastMode) {
      $input.value = parseInt(activeYear) < 2014 ? parseInt(activeYear) + 1 : 1900;
      fireItUp();
    } else {
      clearInterval(coasting);
    }
  }, 25000);

  document.onkeyup = function(e) {
    if (e.keyCode === 13) {
      if (activeYear !== $input.value) {
        fireItUp();
      }
    } else if (e.keyCode === 32) {
      if (activeYear !== $input.value) {
        playlist.toggle();
      }
    }
  };

  $go.addEventListener('click', function(event) {
    if (activeYear !== $input.value) {
      fireItUp();
    }
  });

  function getRandomArbitrary(min, max) {
    return Math.round(Math.random() * (max - min) + min);
  }

  document.querySelector('#go-random').addEventListener('click', function(event) {
    $input.value = getRandomArbitrary(1899, 2014);
    if (activeYear !== $input.value) {
      fireItUp();
    }
  });

  $trackInfo.querySelector('#track-image').addEventListener('click', function(event) {
    playlist.toggle();
  });

  $goodTrack.addEventListener('click', function(event) {
    // TODO I do not know
  });

  $badTrack.addEventListener('click', function(event) {
    playlist.next();
  });

  function fireItUp() {
    if (!$input.validity.valid) {
      console.log('The input is invalid.');
      return false;
    }
    activeYear = $input.value;
    events.pub('yearChange', { year: activeYear });
    getFontForYear(activeYear);
    //var colorPalette = getYearInfo(activeYear, 'colors');
    //$body.style.backgroundColor = colorPalette.background;

    events.pub('clearTrackInfo');
    events.pub('sendMessage', { message: 'Welcome to ' + activeYear + ' - ' + getMessageForYear(activeYear), elType: 'h1' });
    searchTracks($input.value, function(trackList) {
      trackList = trackList.filter(function(track) {
        return track.preview_url;
      });

      playlist.trackList = [];
      bufferLoader.trackList = shuffle(trackList);
      bufferLoader.load();
    });
  }

  events.sub('updateTrackInfo', function(args) {
    var track = args.nowPlaying;
    var $name = document.querySelector('#track-name');
    var $artist = document.querySelector('#track-artist');
    //var $notes = document.querySelector('#track-notes');
    $name.textContent = track.name;
    $artist.textContent = track.artist;
    document.title = track.name;
    //$notes.textContent = track.notes;
    $trackInfo.style.background = 'none';
    if (track && track.album && track.album.images && track.album.images.length > 1) {
      var albumImgUrl = track.album.images[1].url;
      document.querySelector('#track-image').style.background = 'url(' + albumImgUrl + ') no-repeat';
      document.querySelector('#track-image').style.backgroundSize = 'contain';
      document.querySelector('#track-image').style.display = 'inline-block';
    }
  });

  events.sub('clearTrackInfo', function() {
    [].forEach.call($trackInfo.querySelectorAll('p, h1'), function($p) {
      $p.textContent = '';
    });
    [].forEach.call($trackInfo.querySelectorAll('.thumbnail'), function($thumbnail) {
      $thumbnail.style.background = 'none';
      $thumbnail.style.display = 'none';
    });
    $trackInfo.querySelector('#track-image').style.display = 'none';

    events.pub('loadingIndicator', { loading: true });
  });

  events.sub('loadingIndicator', function(data) {
    var loading = data.loading || false; 

    if (loading) {
      $trackInfo.style.background = 'url(/static/img/clock.svg) no-repeat scroll center center';
      $trackInfo.style.backgroundSize = 'contain';
    } else {
      $trackInfo.style.background = 'none';
    }
  });

  events.sub('addBufferImages', function(args) {
    var tracks = args.tracks;
    var $upcoming = document.querySelector('#upcoming-tracks');
    while($upcoming.firstChild) {
      $upcoming.removeChild($upcoming.firstChild);
    }
    var $div;
    tracks.forEach(function(track) {
      if (track && track.album && track.album.images && track.album.images.length > 1) {
        $div = document.createElement('div');
        var albumImgUrl = track.album.images[1].url;
        $div.style.background = 'url(' + albumImgUrl + ') no-repeat';
        $div.style.backgroundSize = 'contain';
        $div.className = 'thumbnail upcoming';
        $upcoming.appendChild($div);
        events.pub('loadingIndicator', { loading: false });
      }
    });
  });

  function shuffle(o){
    for(var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
    return o;
  }

  function searchTracks(year, callback) {
    var trackList;
    if (window.cache && window.cache.songs && typeof window.cache.songs[year] !== 'undefined') {
      var trackList = window.cache.songs[year].slice();
      callback(trackList);
    } else {
      api.getSongs(year, function(xhr) {
        trackList = JSON.parse(xhr.responseText);
        callback(trackList);
      });
    }
  };

  api.get('/api/v1.0/events', function(xhr) {
    var obj = xhr && typeof xhr.response === 'string' ? JSON.parse(xhr.responseText) : {};
    cache.events = obj;
  });

  api.get('/api/v1.0/songs', function(xhr) {
    var obj = xhr && typeof xhr.response === 'string' ? JSON.parse(xhr.responseText) : {};
    cache.songs = obj;
  });

}
</script>
</html>
